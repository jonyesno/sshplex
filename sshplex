#!/usr/bin/env ruby

require 'etc'
require 'logger'
require 'net/ssh'
require 'optparse'
require 'parallel'
require 'reline'

$:.push('.')
require 'output'
require 'plex'

Readline = Reline

options = {}
op = OptionParser.new do |opts|
  opts.banner  = "usage: sshplex [ options ] hosts"

  options[:forward_agent] = false
  opts.on("-A", "--forward-agent") { options[:forward_agent] = true }

  options[:user] = nil
  opts.on("-u", "--user=USER",
          "remote ssh user") { |o| options[:user] = o }

  options[:mode] = :exec
  opts.on("-m", "--mode=(exec|shell)",
          [ :exec, :shell ]) { |o| options[:mode] = o }
  opts.on("-e", "--exec",  "same as --mode exec")  { options[:mode] = :exec }
  opts.on("-s", "--shell", "same as --mode shell") { options[:mode] = :shell }

  options[:output] = :same
  opts.on("-t", "--tmux",
          "use tmux split pane for output") { options[:output] = :tmux }

  options[:loglevel] = :error
  opts.on("-l", "--log-level=LEVEL",
          [ :debug, :info, :warn, :error, :fatal ]) { |o| options[:loglevel ] = o }
  opts.on("-v", "--verbose",
          "same as --log-level debug") { options[:loglevel] = :debug }

  opts.on("-h", "--help") do
    puts opts
    exit
  end
end
op.parse!

hosts = ARGV
raise OptionParser::MissingArgument, "\n#{op.banner}" if hosts.empty?

plex_logger = Logger.new(STDERR, level: Logger.const_get(options[:loglevel].upcase))
cli_logger  = Logger.new(STDERR, level: Logger::INFO)

case options[:output]
when :same
  out = Output.stdout
when :tmux
  out = Output.tmux
end

plex = Parallel.map(hosts, in_threads: 4) { |h|
  cli_logger.info("connecting to #{h}")
  plex = Plex.new(h,
                  agent:  options[:forward_agent],
                  logger: plex_logger,
                  mode:   options[:mode],
                  out:    out.call(h),
                  user:   options[:user],
                 )

  cli_logger.info("connected to #{h}")
  plex
}.select { |p| p.connected? }

Readline.vi_editing_mode

timestamp = Time.now

begin
  loop do
    pending = plex.select { |p| !p.eof? }

    Signal.trap("INT") { plex.map { |p| p.etx! } }

    while pending.length > 0
      if Time.now - timestamp > 10
        done = plex.select { |p| p.eof? || p.idle? }.map(&:hostname)
        wait = plex.map(&:hostname) - done
        cli_logger.info("done: #{done.join(',')}")
        cli_logger.info("wait: #{wait.join(',')}")
        timestamp = Time.now
      end

      p = pending.shift

      p.process

      next if p.eof?
      next if p.idle?

      cli_logger.debug("requeue #{p.hostname}")
      pending.push(p)
    end

    Signal.trap("INT", "DEFAULT")

    if plex.select { |p| !p.eof? }.empty?
      cli_logger.info("all done")
      exit 0
    end

    cmd = Readline.readline("sshplex% ", true)
    break if cmd.nil?
    next if cmd.empty?

    plex.each do |p|
      p.send(cmd)
    end
    timestamp = Time.now
  end
rescue Interrupt
  logger.info("interrupted at prompt")
  exit 1
end

Output.cleanup
