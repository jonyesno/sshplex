#!/usr/bin/env ruby

require 'etc'
require 'logger'
require 'net/ssh'
require 'optparse'
require 'parallel'
require 'reline'
require 'yaml'

$:.push('.')
require 'output'
require 'plex'

Readline = Reline

options = {
  :forward_agent => false,
  :hosts_file    => nil,
  :loglevel      => :error,
  :mode          => :exec,
  :output        => :inline,
  :user          => nil,

  :alias         => {},
}

CONFIG="#{__dir__}/.sshplex.yml"
if File.exist?(CONFIG)
  options.merge!(YAML::load_file(CONFIG).transform_keys(&:to_sym))
end

op = OptionParser.new do |opts|
  opts.banner  = "usage: sshplex [ options ] hosts"

  opts.on("-A", "--forward-agent") { options[:forward_agent] = true }

  opts.on("-f", "--hosts=HOSTS") { |h| options[:hosts_file] = h }

  opts.on("-l", "--log-level=LEVEL",
          [ :debug, :info, :warn, :error, :fatal ]) { |o| options[:loglevel ] = o }
  opts.on("-v", "--verbose",
          "same as --log-level debug") { options[:loglevel] = :debug }

  opts.on("-m", "--mode=(exec|shell)",
          [ :exec, :shell ]) { |o| options[:mode] = o }
  opts.on("-e", "--exec",  "same as --mode exec")  { options[:mode] = :exec }
  opts.on("-s", "--shell", "same as --mode shell") { options[:mode] = :shell }

  opts.on("-t", "--tmux",
          "use tmux split pane for output") { options[:output] = :tmux }

  opts.on("-u", "--user=USER",
          "remote ssh user") { |o| options[:user] = o }

  opts.on("-h", "--help") do
    puts opts
    exit
  end
end
op.parse!

filter = Regexp.new(".")
if options[:hosts_file]
  hosts = File.readlines(options[:hosts_file]).map(&:chomp)
  if ARGV.length > 0
    filter = Regexp.union(ARGV)
  end
else
  hosts = ARGV
end

raise OptionParser::MissingArgument, "\n#{op.banner}" if hosts.empty?
hostlen = hosts.map(&:length).max

plex_logger = Logger.new(STDERR, level: Logger.const_get(options[:loglevel].upcase))
cli_logger  = Logger.new(STDERR, level: Logger::INFO)

case options[:output]
when :inline
  out = Output.stdout
when :tmux
  out = Output.tmux
end

plex = hosts.map { |h| Plex.new(h,
                                agent:  options[:forward_agent],
                                logger: plex_logger,
                                mode:   options[:mode],
                                out:    out.call(h.rjust(hostlen)),
                                user:   options[:user]) }

Parallel.map(plex.select { |p| filter.match(p.hostname) }, in_threads: 12) { |p|
  cli_logger.info("connecting to #{p.hostname}")
  p.open
  cli_logger.info("connected  to #{p.hostname}")
}

Readline.vi_editing_mode

timestamp = Time.now

begin
  loop do
    active = plex
      .select { |p| p.connected? && !p.eof? }
      .select { |p| filter.match(p.hostname) }

    pending = active.dup

    Signal.trap("INT") { plex.map { |p| p.etx! } }

    while pending.length > 0
      if Time.now - timestamp > 10
        done = active.select { |p| p.eof? || p.idle? }.map(&:hostname)
        wait = active.map(&:hostname) - done
        cli_logger.info("done: #{done.join(',')}")
        cli_logger.info("wait: #{wait.join(',')}")
        timestamp = Time.now
      end

      p = pending.shift

      p.process

      next if p.eof?
      next if p.idle?

      cli_logger.debug("requeue #{p.hostname}")
      pending.push(p)
    end

    Signal.trap("INT", "DEFAULT")

    if plex.select { |p| !p.eof? }.empty?
      cli_logger.info("all done")
      exit 0
    end

    cmd = Readline.readline("sshplex% ", true)
    break if cmd.nil?
    next if cmd.empty?

    timestamp = Time.now

    if ctrl_cmd = cmd[/^:(\w+)/, 1]
      case ctrl_cmd
      when 'on'
        if patterns = cmd[/^:on (.*)$/, 1]
          filter = Regexp.union(patterns.split)
          cli_logger.info("host filter #{filter}")
          Parallel.map(plex.select { |p| filter.match(p.hostname) }, in_threads: 12) { |p|
            cli_logger.info("connecting to #{p.hostname}")
            p.open unless p.connected?
            cli_logger.info("connected  to #{p.hostname}")
          }
          next
        else
          cli_logger.info("didn't update host filter")
        end
      else
        if new_cmd = options[:alias][ctrl_cmd]
          Readline.pre_input_hook = -> {
            Readline.insert_text(new_cmd)
            Readline.redisplay
            Readline.pre_input_hook = nil
          }
          next
        else
          cli_logger.info("didn't expand alias #{ctrl_cmd}")
        end
      end
    end

    Readline::HISTORY.push cmd

    plex
      .filter { |p| filter.match(p.hostname) }
      .each { |p| p.send(cmd) }

  end
rescue Interrupt
  logger.info("interrupted at prompt")
  exit 1
end

Output.cleanup
