#!/usr/bin/env ruby

require 'etc'
require 'net/ssh'
require 'optparse'
require 'reline'

Readline = Reline
options = {}
op = OptionParser.new do |opts|
  opts.banner  = "usage: plex [ options ] hosts"

  options[:user] = Etc.getlogin
  opts.on("-u", "--user=USER", "remote ssh user") { |o| options[:user] = o }

  options[:mode] = :exec
  opts.on("-m", "--mode=(exec|shell)", [ :exec, :shell ]) { |o| options[:mode] = o }

  opts.on("-h", "--help") do
    puts opts
    exit
  end
end
op.parse!

hosts = ARGV
raise OptionParser::MissingArgument, "\n#{op.banner}" if hosts.empty?

path = "#{ENV['HOME']}/tmp/plex"
FileUtils.mkdir_p(path)

class Plex
  attr_reader :shell, :hostname, :out, :ssh

  # https://stackoverflow.com/a/29497680
  ANSI_ESCAPE_CODES = Regexp.new('[\u001b\u009b][\[();?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]')

  def initialize(hostname, **kwargs)
    @hostname = hostname
    @out = kwargs[:out] || STDOUT
    @user = kwargs[:user]

    @at_prompt = false
    @prompt = Regexp.new('(^% | \d+ \$ )$')

    @buffer = []
    @ssh_eof = false
    @exec_inflight = false

    self.open
  end

  def open
    @ssh = Net::SSH.start(@hostname, @user, verbose: :warn)
  end

  def shell
    @shell = @ssh.open_channel do |channel|
      STDERR.puts "[plex] established shell channel to #{@hostname}"

      channel.request_pty do |ch, success|
        raise RuntimeError, "pty failed" unless success
      end

      channel.send_channel_request("shell") do |ch, success|
        raise RuntimeError, "shell failed" unless success

        ch.on_data do |ch, data|
          @buffer << data
        end

        ch.on_extended_data do |ch, type, data|
          @buffer << data
        end

        ch.on_request("exit-status") do |ch, data|
          code = data.read_long
          @buffer << "# exit: #{code}\n"
          @ssh_eof = true
        end

        ch.on_request("exit-signal") do |ch, data|
          signal = data.read_long
          @buffer << "# signal: #{signal}\n"
          @ssh_eof = true
        end
      end
    end
  end

  def exec(cmd)
    @exec_pending = true
    @exec = @ssh.open_channel do |channel|
      STDERR.puts "[plex] established exec channel to #{@hostname}"

      channel.exec(cmd) do |ch, success|
        raise RuntimeError, "exec failed" unless success

        ch.on_data do |ch, data|
          @buffer << data
        end

        ch.on_extended_data do |ch, type, data|
          @buffer << data
        end

        ch.on_request("exit-status") do |ch, data|
          code = data.read_long
          @out.puts "# exit: #{code}"
          @exec_pending = false
        end

        ch.on_request("exit-signal") do |ch, data|
          signal = data.read_long
          @out.puts "# signal: #{signal}"
          @exec_pending = false
        end
      end
    end
  end

  def process
    @ssh.process(0.1)
    unless @buffer.empty?

      # join buffer lines, strip of ANSI chaos
      clean = @buffer.join.gsub(ANSI_ESCAPE_CODES, '').gsub("\r", "")

      # emit all the \n terminated lines, keep the current in-progress line
      lines = clean.split(/\n/, -1)
      if lines.empty?
        raise RuntimeError, "eh"
      end

      current = lines.pop
      emit = lines.join("\n")
      unless emit.empty?
        @out.puts emit
      end

      if current.empty?
        @buffer = []
      else
        @buffer = [ current ]
      end

      if current.match(@prompt)
        @at_prompt = true
        @out.puts current.gsub(@prompt, '')

        @buffer = []
      end
    end
  end

  def send(data, mode)
    case mode
    when :shell
      @at_prompt = false
      @buffer = [ 'plex% ' ] # add synthetic prompt to output
      @shell.send_data(data + "\n")
    when :exec
      self.exec(data)
    end
  end

  def at_prompt?
    @at_prompt
  end

  def eof?
    @ssh_eof
  end

  def exec?
    @exec_pending
  end

end

class Outputter
  def initialize(prefix = "", io = STDOUT)
    @io = io
    @prefix = prefix
    @io.sync = true
  end

  def puts(data)
    @io.puts(data.split("\n").map { |l| "#{@prefix} #{l}" }.join("\n"))
  end

  def print(data)
    @io.print(data.split("\n").map { |l| "#{@prefix} #{l}" }.join("\n"))
  end
end


plex = hosts.map { |h| Plex.new(h,
                                user: options[:user],
                                out: Outputter.new("[#{h}]", STDOUT),
                               ) }
mode = options[:mode]

case mode
when :shell
  plex.map { |p| p.shell }
end

STDERR.puts "[loop]"

loop do
  pending = []

  case mode
  when :shell
    pending = plex.select { |p| !p.eof? }
    if pending.length == 0
      STDERR.puts "[all done]"
      exit 0
    end
  when :exec
    pending = plex.dup
  end

  while pending.length > 0
    p = pending.shift
    p.process

    # FIXME generalise
    next if p.eof?
    next if p.at_prompt?
    next if mode == :exec && !p.exec?

    pending.push(p)
  end

  cmd = Readline.readline("plex% ")
  break if cmd.nil?
  next if cmd.empty?

  plex.each do |p|
    p.send(cmd, mode)
  end
end

