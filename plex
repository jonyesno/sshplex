#!/usr/bin/env ruby

require 'etc'
require 'net/ssh'
require 'optparse'
require 'reline'

Readline = Reline
options = {}
op = OptionParser.new do |opts|
  opts.banner  = "usage: plex [ options ] hosts"

  options[:user] = Etc.getlogin
  opts.on("-u", "--user=USER", "remote ssh user") { |o| options[:user] = o }

  opts.on("-h", "--help") do
    puts opts
    exit
  end
end
op.parse!

hosts = ARGV
raise OptionParser::MissingArgument, "\n#{op.banner}" if hosts.empty?

path = "#{ENV['HOME']}/tmp/plex"
FileUtils.mkdir_p(path)

class Plex
  attr_reader :channel, :hostname, :out, :ssh

  # prompt detection is hard when it contains ANSI colour chaos
  # https://stackoverflow.com/a/29497680
  STRIP_ANSI = Regexp.new('[\u001b\u009b][\[();?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]')

  def initialize(hostname, **kwargs)
    @hostname = hostname
    @out = kwargs[:out] || STDOUT
    @user = kwargs[:user]

    @at_prompt = false
    @prompt = Regexp.new('(\r\n% | \d+ \$ )$')

    @buffer = []
    @eof = false

    self.open
  end

  def open
    @ssh = Net::SSH.start(@hostname, @user, verbose: :warn)
    @channel = @ssh.open_channel do |channel|
      STDERR.puts "[plex] established channel to #{@hostname}"

      channel.request_pty do |ch, success|
        raise RuntimeError, "pty failed" unless success
      end

      channel.send_channel_request("shell") do |ch, success|
        raise RuntimeError, "shell failed" unless success

        ch.on_data do |ch, data|
          @buffer << data
        end

        ch.on_extended_data do |ch, type, data|
          @buffer << data
        end

        ch.on_request("exit-status") do |ch, data|
          code = data.read_long
          @out.puts "# exit: #{code}"
          @out.flush
          @eof = true
        end

        ch.on_request("exit-signal") do |ch, data|
          signal = data.read_long
          @out.puts "# signal: #{signal}"
          @out.flush
          @eof = true
        end
      end
    end
  end

  def process
    current = @buffer.length
    @ssh.process(0.1)
    if @buffer.length > current

      clean = @buffer.join.gsub(STRIP_ANSI, '')

      if clean.match(@prompt)
        @at_prompt = true
        @out.print(clean)
        @out.flush

        @buffer = []
      end
    end
  end

  def send(data)
    @out.puts "# command: #{data}"
    @at_prompt = false
    @channel.send_data(data)
  end

  def alive?
    !@eof
  end

  def at_prompt?
    @at_prompt
  end

end

plex = hosts.map { |h| Plex.new(h, user: options[:user]) }

STDERR.puts "[loop]"

loop do
  pending = plex.select(&:alive?)

  if pending.length == 0
    STDERR.puts "[all done]"
    exit 0
  end

  while pending.length > 0
    p = pending.shift
    p.process
    pending.push(p) unless p.at_prompt?
  end

  cmd = Readline.readline("plex% ")
  break if cmd.nil?
  next if cmd.empty?

  plex.each do |p|
    p.send(cmd + "\n")
  end
end

